Multithreading:

*Why we need to learn Multithreading?
--Reduce response time and to improve the performance
to work with multi media graphics
to work with animations
to develop servers like tomcat web logic 
Modern computers have multiple CPU cores.
Multithreading allows a program to run multiple tasks in parallel, making full use of CPU resources.
Example:
One thread â†’ calculations
Another thread â†’ file reading
Another thread â†’ database calls
Without multithreading, these tasks run one after another, wasting CPU time.
Tasks that are independent can run at the same time
All can happen simultaneously, reducing total execution time.
In single-threaded programs, long tasks block everything else.
Handling thousands of users
Background processing
Better system stability
improve performance
Use CPU efficiently
Build responsive applications
 
*What is multithreading?
--Multithreading is a programming concept where multiple threads execute concurrently within a single process to perform multiple tasks at the same time.
In simple words:
Doing more than one task simultaneously within the same program is called multithreading.
Multithreading is a process or concept running multiple threads at a time if we want to 
do any tasks simultaneously then we will go for Multithreading for example we use our laptop to write programs at a time we draw on paints and note some points on notepad 
 in multithreading thread is  a light weight process uses multiple processors executes in stack area  to run the task fast and reduce response time 

*What is thread?
--Thread is a class from java.lang package
Thread is a light weight execution process which happening inside the  stack area
Instead of executing tasks one after another  2 threads are parallelly is known as multithreading
In java every small program has a Thread that is main thread
if e want to check Thread.currentThread().getName()
What ever happening in side the stack is called is called thread
A thread in Java is the smallest unit of execution within a program.
It represents an independent path of execution that can run concurrently with other threads.
In simple words:
A thread allows multiple tasks to run at the same time inside a single program.
One process can have multiple threads.
Thread = independent execution path
Threads run inside a process
utilizing the cpu in a same time

*Multithreading is a term came from Multitasking
Multitasking means doing multiple things in a same time
There are two types of multitasking 
1)PBM -Process based multitasking -related to CPU
2)TBM- Thread based Multi tasking -thread
in PBM each task is a independent program
in TBM each task is a part of the program

In Java we can create thread in two ways
1) extending the Thread class
2) implementing Runnable Interface
-A normal class is not a Thread class until we implement Runnable or extends Thread but in each class we have the Thread the main 

What is a General Synchronous Process?
A synchronous process is an execution model where tasks are performed one after another, in a fixed sequence.
Each task must complete first before the next task starts.
In simple words:
One task blocks the next task until it finishes.
Sequential execution
Blocking in nature
Only one task runs at a time
Whatever functionality we want to run parallelly with main Thread that we need to keep inside the run method overriding from the Thread class
Thread implements Runnable
starting the thread causes the objects run run method to be called 
start() method will call the run()
if we want to call run() we must need to call start()
Thread class run() method does not have anything it has just plain implementation of runnable run() we must need to Override that method into our class

*Why we need to Override run()?
In Java, run() is the method that contains the task (job) a thread should execute.
When you create a thread, Java does not know what work your thread should do, so you must override run() and define that work.
Default run() does nothing useful
The Thread class already has a run() method, but its default implementation is empty (or just calls a target Runnable if provided).
If you donâ€™t override run():
The thread will start
But no code will execute
start() internally calls run()
start() â†’ creates a new thread
JVM internally calls run()
We override the run() method to define the task that a thread should execute. Without overriding run(), the thread has no job to perform, and calling start() will not execute any meaningful code.
start() method causes the thread to begin execution the java virtual machine call the run method of this thread
we can not predict the  out put of the multithreading program
run()
 
*Why don't we call run method ?
It contains the task / logic that a thread should execute.

You override this method.

If you call run() directly, it behaves like a normal method call (no new thread).

start()

It is a Thread class method.

It creates a new thread.

It internally calls run().
JVM asks the OS to create a new thread

JVM performs thread initialization

JVM calls the threadâ€™s run() method

The code inside run() executes in a new thread

ğŸ‘‰ You do NOT call run() directly
ğŸ‘‰ JVM calls run() automatically
* If we call run method directly it runs in main thread

*What happens if a class extends Thread and implements Runnable?
--thread class already implementing runnable so there is no use of again implementing

*extends Thread is not a recommended approach implements Runnable is good why?
--Because if we extends a Thread class then we are unable to extend another class because multiple inheritance is not possible in  so if we implements Runnable we extends another class  
  we can not miss that inheritance 
Java supports single inheritance

If you extend Thread, you lose the chance to extend any other class.

class MyThread extends Thread {

}
class MyThread extends Thread extends Employee // âŒ Not allowed
But with Runnable, you are free to extend another class:
class MyTask extends Employee implements Runnable {
    public void run() {
        // task logic
    }
}
Runnable â†’ what task to run
Thread â†’ how to run the task
A Runnable object can be reused by multiple threads.
Implementing Runnable is preferred over extending Thread because Java supports single inheritance, Runnable allows better design, reusability, and works with the Executor framework, making it suitable for real-world applications.

* If multiple threads are waiting for the execution which thread will executed is decided by the thread scheduler 
Thread scheduler is  the part of the JVM and we can not expect an exact algorithm followed by Thread Scheduler it varies form JVM to JVM hence we can not expect exact output but we provide several possible outputs 

*Difference between start() and run()?

run() is an abstract method from Runnable interface
--start() method
it is a void method and does not take any value and does not return any value 
it is a instance method we need to call by reference variable 

Creates a new thread
JVM allocates separate call stack
Internally calls the run() method
Executes code concurrently
Multithreading happens
Parallel execution
Called only once per thread
run() method
No new thread is created
Executes like a normal method
Uses main threadâ€™s stack
No concurrency
No multithreading
No parallel execution
Feature	                start()	run()
Creates new thread	âœ… Yes	âŒ No
Separate call stack	âœ… Yes	âŒ No
Executes concurrently	âœ… Yes	âŒ No
JVM involvement	        âœ… Yes	âŒ No
Can be called multiple times	âŒ No	âœ… Yes (like normal method)
Calling start() twice causes:
IllegalThreadStateException
Interview-ready one-line answer
start() creates a new thread and internally calls run(), whereas run() executes like a normal method without creating a new thread.

* If we did not Override run() and call start() method which method will execute ?
The run() method of the Thread class will execute â€” not your own code.
Why does this happen?
start() always calls run()
If you do not override run(), JVM executes the default run() implementation from the Thread class
The default run() method does nothing useful
If the thread was created without a Runnable target â†’ target == null
So, no code runs
Thread starts
No task executed in the new thread
If we do not override run() and call start(), the JVM executes the default run() method of the Thread class. If no Runnable target is provided, the thread runs but performs no action.

*Difference between Thread and Runnable?
--What is Thread?
Thread is a class
Represents a thread of execution
Contains thread lifecycle methods: start(), sleep(), join(), etc.
Used to create and run a thread
What is Runnable?
Runnable is a functional interface
Represents a task/job
Contains only one method: run()
Does not create a thread by itself
Runnable = WHAT to run
Thread = HOW to run
Feature	Thread	Runnable
Type	                   Class	Interface
Purpose	Creates and controls a thread	Defines the task
Inheritance	Cannot extend any other class	Can extend another class
Multiple inheritance	âŒ Not possible	âœ… Possible
Reusability	âŒ Less reusable	âœ… More reusable
Executor framework	âŒ Not supported	âœ… Supported
Memory	Heavy object	Lightweight
Best practice	âŒ Not recommended	âœ… Recommended
Thread is a class that represents a thread of execution, whereas Runnable is an interface that represents a task. Implementing Runnable is preferred because it supports multiple inheritance, better design, reusability, and works with the Executor framework.


Why does Java provide wait(), notify(), notifyAll() in Object class and not in Thread class?
--wait() / notify() are about objects, not threads
ğŸ‘‰ Threads do not wait on threads.
ğŸ‘‰ Threads wait on objects (locks / monitors).
In Java:
Every object has an intrinsic lock (monitor)
A thread acquires an objectâ€™s lock
Then it can:
wait() â†’ release that objectâ€™s lock and go to waiting state
notify() â†’ wake up a thread waiting on the same object
ğŸ“Œ Since lock belongs to the object, these methods must belong to Object class.
Lock is on obj
Waiting is on obj
Notification is on obj
â“ If wait() were in Thread class:
Which objectâ€™s lock would be released?
Which monitor would be used?
â¡ï¸ This ambiguity is why Java designers did not put them in Thread class.
Multiple threads
âœ” Single shared object
âœ” Coordination happens through objectâ€™s monitor
This cannot work if wait() were inside Thread.
4ï¸âƒ£ Every object can be used as a lock
Because wait() / notify() are in Object:
Any object can act as a communication channel
No need for special thread objects
Flexible
âœ” Powerful
âœ” Clean design

5ï¸âƒ£ JVM rule (very important âš ï¸)

A thread must own the objectâ€™s monitor before calling wait() or notify().
Otherwise:
IllegalMonitorStateException
This rule only makes sense when these methods belong to Object.
6ï¸âƒ£ What would go wrong if they were in Thread?
If wait() were in Thread class:
Threads would wait on themselves
No shared communication mechanism
Producerâ€“consumer, inter-thread communication would break
ğŸš« Bad design
ğŸš« No object-level coordination
7ï¸âƒ£ Interview-ready answer â­
Java provides wait(), notify(), and notifyAll() in the Object class because these methods work on object monitors. Inter-thread communication in Java is based on shared objects and their locks, not on thread objects. Since every object has a monitor, placing these methods in Object allows any object to be used for synchronization.
ğŸ”‘ One-line memory trick
Lock belongs to object â†’ wait/notify belong to Object class
First understand ONE rule (most important)
ğŸ‘‰ Threads do NOT wait on threads
ğŸ‘‰ Threads wait on OBJECTS
This single line is the key.
Everything else comes from this.
2ï¸âƒ£ What does â€œwaitâ€ actually mean?
When a thread calls wait():
The thread stops executing
It releases the lock of an object
It waits until another thread calls notify() on the SAME object
So the waiting is related to an object, not to a thread.
3ï¸âƒ£ Simple real-life example ğŸª‘ (Chair example)
Imagine:
ğŸª‘ Chair = Object
ğŸ‘©â€ğŸ“ğŸ‘¨â€ğŸ“ Students = Threads
Rule:
Students wait for the chair, not for another student.
If chair is not free:
Student waits on the chair
When chair becomes free:
Another student notifies on the chair
â¡ï¸ Waiting + notifying is happening on the chair (object).
Object lock = new Object();
synchronized (lock) {
    lock.wait();   // thread waits on THIS object
}
âœ” Thread is waiting
âœ” Waiting is done on lock object
Another thread:
java
Copy code
synchronized (lock) {
    lock.notify(); // wakes up waiting thread on SAME object
}
âœ” Communication happens through object

5ï¸âƒ£ Why NOT put wait() in Thread class?
âŒ If wait() was in Thread:

java
Copy code
t1.wait();
Now think:

â“ Which lock is released?
â“ Which object is shared?
â“ How will another thread notify it?
ğŸ‘‰ No shared object = no communication
So Thread-based waiting makes no sense.
6ï¸âƒ£ Why Object is the correct place âœ…
âœ” Every object in Java has a lock
âœ” Multiple threads can share one object
âœ” Threads can coordinate using that shared object
Thatâ€™s why Java designers said:
â€œPut wait(), notify(), notifyAll() inside Object classâ€
So ANY object can be used for communication.
7ï¸âƒ£ One more very clear example (ATM ğŸ’³)
ATM machine â†’ Object
People â†’ Threads
If ATM is busy:
Person waits on ATM
When ATM is free:
ATM notifies waiting person
ğŸ‘‰ People donâ€™t wait on people
ğŸ‘‰ People wait on ATM (object)

8ï¸âƒ£ Final simple answer (memorize this â­)
Java put wait(), notify(), and notifyAll() in the Object class because threads communicate by waiting on shared objects. Since locks belong to objects (not threads), these methods must be in the Object class, not in the Thread class.

ğŸ”‘ One-line shortcut (interview gold)
Lock belongs to object â†’ wait/notify belong to Object class

* sleep() 
sleep() in Java â€” explained very clearly sleep() is a method from thread class it is a static method that's why we must need to call by its call name and it takes milli sec does not return anything
Letâ€™s go step by step, very simple, no confusion.
1ï¸âƒ£ What is sleep()?
ğŸ‘‰ sleep() is used to pause the current thread for a fixed amount of time.
Thread.sleep(1000); // sleep for 1 second
âœ” Thread stops temporarily
âœ” After time is over, thread automatically resumes
2ï¸âƒ£ Who provides sleep()?
sleep() is a static method of the Thread class
Thread.sleep(time);
ğŸ“Œ That means:
It always affects the currently executing thread
Not any other thread

3ï¸âƒ£ Does sleep() release the lock? âŒ (Very important)
ğŸ‘‰ NO
If a thread holds a lock
And calls sleep()
The lock is NOT released
synchronized(lock) {
    Thread.sleep(2000); // lock is still held
}
Other threads cannot enter this block during sleep.

*4ï¸âƒ£ sleep() vs wait() (core difference)
Feature	sleep()	wait()
Class	Thread	Object
Releases lock	âŒ No	âœ… Yes
Needs synchronized block	âŒ No	âœ… Yes
Wake-up	Time-based	notify() / notifyAll()
Purpose	Pause execution	Inter-thread communication
5ï¸âƒ£ Simple real-life example ğŸ•’
sleep():
You set an alarm for 10 minutes
You sleep
Alarm rings â†’ you wake up automatically
wait():
You wait for your friend to call
Until friend calls (notify()), you donâ€™t wake up
6ï¸âƒ£ Example code
class MyThread extends Thread {
    public void run() {
        try {
            System.out.println("Sleeping...");
            Thread.sleep(2000);
            System.out.println("Awake!");
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

public class Test {
    public static void main(String[] args) {
        new MyThread().start();
    }
}

Output:
Sleeping...
Awake!
(after 2 seconds)


7ï¸âƒ£ Why sleep() is in Thread class?
ğŸ‘‰ Because:
Sleeping is related to thread execution
Not related to object locks
No communication between threads
So it belongs in Thread, unlike wait().
8ï¸âƒ£ Interview-ready answer â­
sleep() pauses the currently executing thread for a specified time without releasing any locks. It is a static method of the Thread class and is used to slow down execution or simulate delays.
ğŸ”‘ One-line memory trick
sleep = time-based pause, no lock release


*1ï¸âƒ£ What is yield()?
ğŸ‘‰ yield() tells the currently running thread: â€œI am willing to pause and give other threads of the same priority a chance to execute.â€ it tells to thread scheduler 
it is a static method it does not take any value and does not return anything 
Thread.yield();
âœ” It is only a suggestion to the scheduler
âœ” JVM/OS may ignore it

2ï¸âƒ£ Who provides yield()?
yield() is a static method of the Thread class
Affects current thread only
Thread.yield();
3ï¸âƒ£ What actually happens internally?
Running thread â†’ moves from Running state to Runnable state
Scheduler may choose:
Same thread again âŒ
Another thread of same priority âœ…
âš ï¸ No guarantee of context switch.
4ï¸âƒ£ Does yield() release lock? âŒ
ğŸ‘‰ NO
Just like sleep()
Lock is still held
synchronized(lock) {
    Thread.yield(); // lock NOT released
}


5ï¸âƒ£ yield() vs sleep() vs wait() (easy table)
Feature	        yield()	      sleep()	            wait()
Class	       Thread	       Thread	        Object
Pause time 	Not defined	Fixed time	Until notify
Releases lock 	âŒ No	         âŒ No	       âœ… Yes
Scheduler control  Hint only   Forced	Object-based
Use case	Improve fairness	Delay execution	Thread communication
6ï¸âƒ£ Simple real-life example ğŸš¦
yield():
You are driving
You slow down to let another car pass
You may continue immediately
sleep():
You stop your car for 5 minutes
wait():
You park and wait until someone calls you
7ï¸âƒ£ Example code
class MyThread extends Thread {
    public void run() {
        for(int i = 1; i <= 5; i++) {
            System.out.println(Thread.currentThread().getName() + " : " + i);
            Thread.yield();
        }
    }
}

public class Test {
    public static void main(String[] args) {
        MyThread t1 = new MyThread();
        MyThread t2 = new MyThread();

        t1.start();
        t2.start();
    }
}
ğŸ“Œ Output order is not guaranteed.

8ï¸âƒ£ When should we use yield()?
âœ… Rarely used in real projects
âœ… Mostly for:
Testing
Demonstrations
Giving CPU chance to other threads

âŒ Not reliable for synchronization

9ï¸âƒ£ Interview-ready answer â­

yield() is a static method of the Thread class that temporarily pauses the currently executing thread and gives other threads of the same priority a chance to execute. It does not release locks and provides no guarantee that another thread will run.
ğŸ”‘ One-line memory trick
yield = polite request to scheduler

*What is join()?
ğŸ‘‰ join() is used when one thread wants to wait for another thread to finish.
In short:
â€œFinish your work first, then I will continue.â€
2ï¸âƒ£ Who provides join()?
join() is a non-static method of the Thread class
It is called on a Thread object
t.join();
3ï¸âƒ£ What happens internally?
When thread A calls:
t.join();
Thread A goes into WAITING state
Thread A waits until thread t completes execution
After t finishes â†’ thread A resumes
it also throws InterruptedException 
4ï¸âƒ£ Simple real-life example ğŸ“
Teacher = main thread
Student = child thread
Teacher says:
â€œFinish your exam first, then Iâ€™ll check papers.â€
That waiting = join()
5ï¸âƒ£ Very simple example code
class MyThread extends Thread {
    public void run() {
        for(int i = 1; i <= 3; i++) {
            System.out.println("Child thread: " + i);
        }
    }
}

public class Test {
    public static void main(String[] args) throws InterruptedException {
        MyThread t = new MyThread();
        t.start();
        t.join(); // main thread waits here
        System.out.println("Main thread continues");
    }
}

Output:
Child thread: 1
Child thread: 2
Child thread: 3
Main thread continues
âœ” Main thread waits
âœ” Child thread completes
âœ” Then main thread runs

6ï¸âƒ£ Does join() release lock? âŒ
ğŸ‘‰ No
join() does not release any locks
It only blocks the calling thread
7ï¸âƒ£ join() with time â±ï¸
t.join(2000); // wait max 2 seconds


Main thread waits up to 2 seconds

If thread finishes early â†’ resumes immediately

If not â†’ resumes after timeout

8ï¸âƒ£ join() vs sleep() vs wait()
Feature             	join()	                         sleep()	wait()
Purpose	               Wait for thread to finish	Pause thread	Thread communication
Class            	Thread	   Thread	                                Object
Time-based	                 Optional	             Yes	No
Releases lock	                           âŒ No	âŒ No	      âœ… Yes
9ï¸âƒ£ Where is join() used in real projects?
âœ… Ensure task order
âœ… Complete background job before continuing
âœ… Example:
Load data â†’ join()
Process data â†’ main thread continues
ğŸ”Ÿ Interview-ready answer â­

join() is a method of the Thread class that causes the current thread to wait until the specified thread completes execution.
ğŸ”‘ One-line memory trick
join = â€œwait till you finishâ€
*Whenever we call start() method two time over one thread then it throws IlligalThreadStateExceptiion 
-Thread.currentThread() returning Thread 
When we call Thread.sleep() it will throw InturruptedException surrounded with try and catch why not throws means if child class throws any exceptions parent class must need to throw child exception or parent exception 
What is interrupt()?

* interrupt() is used to request a thread to stop what it is doing.
Important:
interrupt() does NOT forcefully stop a thread.
it does not stop thread execution forcefully
It only sends a signal (interrupt request).

t.interrupt();
2ï¸âƒ£ Who provides interrupt()?
interrupt() is a non-static method of the Thread class
Called by one thread on another thread
3ï¸âƒ£ What happens when a thread is interrupted?
Case 1ï¸âƒ£: Thread is in sleep(), wait(), or join()
ğŸ‘‰ JVM throws InterruptedException
Thread.sleep(1000); // interrupted here
âœ” Thread wakes up
âœ” Exception is thrown
âœ” You must handle it
Case 2ï¸âƒ£: Thread is running normally
ğŸ‘‰ No exception is thrown
ğŸ‘‰ Interrupt flag is set to true
Thread must check the flag manually:
if (Thread.currentThread().isInterrupted()) {
    // stop work
}
4ï¸âƒ£ Very simple example (sleep case)
class MyThread extends Thread {
    public void run() {
        try {
            System.out.println("Thread sleeping...");
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            System.out.println("Thread interrupted!");
        }
    }
}

public class Test {
    public static void main(String[] args) {
        MyThread t = new MyThread();
        t.start();

        t.interrupt(); // interrupting the thread
    }
}

Output:
Thread sleeping...
Thread interrupted!

5ï¸âƒ£ Example: Interrupting a running loop
class MyThread extends Thread {
    public void run() {
        while (!Thread.currentThread().isInterrupted()) {
            System.out.println("Working...");
        }
        System.out.println("Stopped safely");
    }
}

public class Test {
    public static void main(String[] args) {
        MyThread t = new MyThread();
        t.start();

        t.interrupt();
    }
}

âœ” Clean stop
âœ” No forceful termination

6ï¸âƒ£ Why stop() is deprecated but interrupt() is not âŒâœ…
stop() â†’ kills thread immediately â†’ unsafe
interrupt() â†’ polite request â†’ safe
ğŸ‘‰ Thatâ€™s why Java recommends interrupt().
7ï¸âƒ£ interrupt() vs stop() vs yield()
Method	Behavior
interrupt()	Requests thread to stop
stop()	Forcefully stops (deprecated)
yield()	Gives chance to other threads
8ï¸âƒ£ Interview-ready answer â­
interrupt() is a method of the Thread class used to signal a thread that it should stop or change its execution. It does not stop the thread forcibly but sets an interrupt flag or throws InterruptedException if the thread is in a waiting or sleeping state.

ğŸ”‘ One-line memory trick
interrupt = polite stop request
whenever thread is in sleep mode then only we can call interrupt() then we get Interrupt exception
when we create object at class level JVM will give you the null values 
join() will throw nullPointerExeption
when we declare reference variable 
If we use Throws for Interrupted exception we must need to throws the parent class the same exception so that we keep join() with try catch

*What is a Daemon Thread?
ğŸ‘‰ A daemon thread is a background thread that runs only to support user threads.
ğŸ“Œ JVM rule:
When all user (non-daemon) threads finish, JVM stops â€” even if daemon threads are still running.
2ï¸âƒ£ User Thread vs Daemon Thread
User Thread	   Daemon Thread
Does main work	Supports background work
Keeps JVM alive	Does NOT keep JVM alive
Example: main()	Example: Garbage Collector
3ï¸âƒ£ Real-life example ğŸŒ
User threads â†’ Students writing exam
Daemon thread â†’ Sweeper cleaning classroom
When students leave:
Sweeper stops automatically
4ï¸âƒ£ Default behavior
main thread â†’ User thread
Threads created by main â†’ User threads by default
Garbage Collector â†’ Daemon thread
5ï¸âƒ£ How to create a daemon thread?
âš ï¸ Important rule:
You must set daemon BEFORE calling start()
class MyThread extends Thread {
    public void run() {
        while (true) {
            System.out.println("Daemon running...");
        }
    }
}

public class Test {
    public static void main(String[] args) {
        MyThread t = new MyThread();
        t.setDaemon(true); // must be before start()
        t.start();

        System.out.println("Main thread ends");
    }
}
Output:
Main thread ends
âœ” JVM exits
âœ” Daemon thread stops automatically

6ï¸âƒ£ What happens if you set daemon after start()? âŒ
t.start();
t.setDaemon(true); // âŒ
â¡ï¸ Runtime Exception:
IllegalThreadStateException
7ï¸âƒ£ Can daemon threads do important work? âŒ
ğŸ‘‰ NO
JVM can stop daemon threads at any time
They may not complete execution
âœ” Use daemon threads only for:
Logging
Monitoring
Garbage collection
Background cleanup
8ï¸âƒ£ How to check if a thread is daemon?
boolean b = t.isDaemon();

9ï¸âƒ£ Daemon vs Normal Thread (quick table)
Feature	Daemon Thread	User Thread
JVM waits for it	âŒ No	âœ… Yes
Purpose	Background support	Main logic
GC example	âœ…	âŒ
Risk of stopping	High	Low
ğŸ”Ÿ Interview-ready answer â­
A daemon thread is a low-priority background thread that provides support to user threads. JVM does not wait for daemon threads to complete execution; once all user threads finish, daemon threads terminate automatically.
ğŸ”‘ One-line memory trick
User thread = main work, Daemon thread = background helper
Difference between Daemon Thread and Normal (User) Thread in Java ğŸ§µ
Iâ€™ll explain this very clearly, with examples and an interview-ready table.
1ï¸âƒ£ Normal (User) Thread
ğŸ‘‰ A normal thread performs the main task of the application.
JVM waits for it to finish
Keeps the application alive
Example: main() thread, business logic threads
Thread t = new Thread(() -> System.out.println("User thread"));
t.start();
2ï¸âƒ£ Daemon Thread
ğŸ‘‰ A daemon thread runs in the background to support user threads.
JVM does NOT wait for it
Automatically stops when all user threads finish
Example: Garbage Collector
Thread t = new Thread(() -> {
    while(true) {
        System.out.println("Daemon running");
    }
});
t.setDaemon(true);
t.start();
3ï¸âƒ£ Most important JVM rule â­
JVM exits when all normal (user) threads finish, even if daemon threads are still running.
4ï¸âƒ£ Real-life example ğŸŒ
ğŸ‘©â€ğŸ’¼ Office employees â†’ User threads
ğŸ§¹ Cleaner â†’ Daemon thread
When employees leave:
Cleaner stops automatically
5ï¸âƒ£ Key Differences Table (Interview Gold)
Feature	                   Normal Thread	Daemon Thread
Purpose	               Main application work	Background support
JVM waits for completion	 âœ… Yes	âŒ No
Keeps JVM alive          	âœ… Yes	    âŒ No
Priority	                Normal	Low
Example                 	main()	Garbage Collector
Risk of abrupt stop	âŒ Low	âœ… High
Suitable for critical tasks	âœ… Yes	  âŒ No
6ï¸âƒ£ Important rules âš ï¸
setDaemon(true) must be called before start()
Changing daemon status after start â†’ IllegalThreadStateException
Daemon threads should not handle important logic (DB, files, payments)
7ï¸âƒ£ Interview-ready short answer â­
A normal thread performs the main work of an application and keeps the JVM alive, whereas a daemon thread runs in the background to support user threads and does not prevent JVM termination.
ğŸ”‘ One-line memory trick
User thread keeps JVM alive, daemon thread dies with JVM
*Thread Life Cycle in Java â€” explained very clearly ğŸ§µğŸ”„
This is very important for interviews. Iâ€™ll keep it simple, step-by-step.

*1ï¸âƒ£ States in Thread Life Cycle
Java thread has 6 states:
NEW
 â†“ start()
RUNNABLE
 â†“ (CPU scheduling)
RUNNING
 â†“ wait/sleep/join
WAITING / TIMED_WAITING / BLOCKED
 â†“ notify / time over / lock acquired
RUNNABLE
 â†“ run() ends
TERMINATED

2ï¸âƒ£ Each state explained simply
ğŸ”¹ 1. NEW
Thread object is created
start() not called yet
Thread t = new Thread();
ğŸ”¹ 2. RUNNABLE
start() is called
Thread is ready to run
Waiting for CPU time
t.start();
ğŸ“Œ In Java, RUNNABLE includes RUNNING
ğŸ”¹ 3. RUNNING
Thread is currently executing run()
CPU is allocated
ğŸ”¹ 4. BLOCKED
Thread is waiting for a lock
Happens in synchronized block
synchronized(obj) {
   // another thread holds lock
}
ğŸ”¹ 5. WAITING
Thread waits indefinitely
Until another thread calls notify() or notifyAll()
obj.wait();
t.join();
ğŸ”¹ 6. TIMED_WAITING
Thread waits for specific time
Thread.sleep(1000);
obj.wait(1000);
t.join(1000);
ğŸ”¹ 7. TERMINATED (Dead)
run() method completed
Thread is finished
Cannot restart
3ï¸âƒ£ Simple example showing lifecycle
class MyThread extends Thread {
    public void run() {
        try {
            Thread.sleep(1000); // TIMED_WAITING
        } catch (Exception e) {}
    }
}

public class Test {
    public static void main(String[] args) {
        MyThread t = new MyThread(); // NEW
        t.start();                  // RUNNABLE
    }
}

4ï¸âƒ£ Lifecycle with method mapping (Interview â­)
Method	    State Change
new  Thread()	NEW
start()	  NEW â†’ RUNNABLE
CPU allocates	RUNNABLE â†’ RUNNING
sleep()	RUNNING â†’ TIMED_WAITING
wait()	RUNNING â†’ WAITING
Lock not available	RUNNING â†’ BLOCKED
notify()	WAITING â†’ RUNNABLE
Time over	TIMED_WAITING â†’ RUNNABLE
run() ends	RUNNING â†’ TERMINATED
5ï¸âƒ£ Real-life example ğŸš¦
NEW â†’ Car created
RUNNABLE â†’ Car ready on road
RUNNING â†’ Car moving
BLOCKED â†’ Traffic signal red
WAITING â†’ Waiting for green signal
TERMINATED â†’ Destination reached
6ï¸âƒ£ Interview-ready answer â­
The thread life cycle in Java consists of states like New, Runnable, Running, Blocked, Waiting, Timed Waiting, and Terminated. A thread moves between these states based on method calls and CPU scheduling until it completes execution.
ğŸ”‘ One-line memory trick
New â†’ Runnable â†’ Running â†’ Waiting/Blocked â†’ Runnable â†’ Terminated

*1ï¸âƒ£ What is Locking?
ğŸ‘‰ Locking means allowing only one thread at a time to access a shared resource.
In Java:
Lock is taken using synchronized
Lock belongs to an object
synchronized(obj) {
    // critical section
}
âœ” Prevents data corruption
âœ” Ensures thread safety

ğŸ” 2ï¸âƒ£ Why is Locking needed?
Without locking:
Two threads access same data
Data becomes inconsistent
Example (ATM ğŸ’³)
Two users withdraw money at same time â†’ âŒ wrong balance
Lock ensures â†’ one withdrawal at a time âœ”
3ï¸âƒ£ Example of Locking
class Account {
    int balance = 1000;

    synchronized void withdraw(int amt) {
        balance -= amt;
        System.out.println(balance);
    }
}
âœ” Only one thread can enter withdraw() at a time

â˜ ï¸ 4ï¸âƒ£ What is Deadlock?
ğŸ‘‰ Deadlock happens when two or more threads wait forever for each otherâ€™s locks.
ğŸ“Œ No thread can proceed
ğŸ“Œ Program hangs
5ï¸âƒ£ Deadlock example (very important âš ï¸)

class DeadlockDemo {
    static Object lock1 = new Object();
    static Object lock2 = new Object();

    public static void main(String[] args) {

        Thread t1 = new Thread(() -> {
            synchronized(lock1) {
                System.out.println("T1 got lock1");
                synchronized(lock2) {
                    System.out.println("T1 got lock2");
                }
            }
        });

        Thread t2 = new Thread(() -> {
            synchronized(lock2) {
                System.out.println("T2 got lock2");
                synchronized(lock1) {
                    System.out.println("T2 got lock1");
                }
            }
        });

        t1.start();
        t2.start();
    }
}

What happens?

T1 holds lock1 â†’ waits for lock2

T2 holds lock2 â†’ waits for lock1

âŒ Infinite waiting = Deadlock

6ï¸âƒ£ Deadlock conditions (Coffman Conditions) â­
Deadlock occurs only if ALL 4 conditions exist:
Mutual exclusion â€“ lock held by one thread
Hold and wait â€“ holding one lock, waiting for another
No preemption â€“ lock canâ€™t be taken forcibly
Circular wait â€“ T1 â†’ T2 â†’ T1
7ï¸âƒ£ How to prevent Deadlock? âœ…
âœ” 1. Lock ordering (Best method)
Always acquire locks in same order
synchronized(lock1) {
    synchronized(lock2) {
        // safe
    }
}

âœ” 2. Avoid nested locks
Try not to lock multiple objects at once.
âœ” 3. Use tryLock() (Advanced)
From java.util.concurrent.locks
âœ” 4. Use single lock
Simpler design reduces risk.
8ï¸âƒ£ Locking vs Deadlock (Quick table)
Locking	               Deadlock
Controls thread access	Stops threads forever
Required for safety	Programming error
Improves correctness	Freezes application
9ï¸âƒ£ Interview-ready answer â­

Locking ensures that only one thread accesses a shared resource at a time, while deadlock is a situation where two or more threads wait indefinitely for each otherâ€™s locks, causing the program to freeze.
ğŸ”‘ One-line memory trick
Locking protects data, Deadlock kills execution
Thread.currentThread() will give number of thread and thread name priority of thread, currently running thread
Thread.getPriority() 
maxPriority();
setName()
getName()

***SYNCHRONIZATION
whenever we are working with multithreading where multiple threads are trying to access the resources in a given point of time in such cases there mighty be a chance of data inconsistency  problems will come to resolve those problems will use synchronization 
synchronization will achieve with below concepts like 
1) mutation
synchronization for threads
synchronization with blocks
2) interthread communication
wait() wai(long ms)  wait(long ms,long ns)
notify() notifyAll()
executing thread one after another is called as once one thread entered into synchronization block that will consider as a lock 
until first thread releasing the lock no thread are unable to enter into the synchronized block 
two threads are communicating then we need to an object give the communication between two threads 
wait() interruptedException 
IlligalMonitarStateException
when we us wait inside the methods we must keep our method synchronizes 

DeadLock
setDaemon(true) it must be first before start()

*If we call start() and run() at a time what will happen?
java.lang.thread is a default package that is  why we are calling thread methods without creating any Thread object

***************************
***************
**********
******
*








